ðŸ§  TOP INTERVIEW QUESTIONS ON â€œDATA TYPESâ€ (With Best Answers)

ðŸ’¬ Question 1: What are the different data types in JavaScript?
âœ… Answer:
JavaScript has 8 data types â€” 7 primitive types and 1 non-primitive (object) type.

Primitive types:

String â€“ represents textual data ("Hello")
Number â€“ represents numeric values (42, 3.14)
Boolean â€“ true or false values
Undefined â€“ a variable that has been declared but not assigned
Null â€“ represents intentional absence of value
Symbol â€“ unique and immutable value introduced in ES6
BigInt â€“ used to represent very large integers (added in ES2020)

Non-Primitive type:

Object â€“ collections of key-value pairs (including Arrays, Functions, Dates, etc.)

âœ… Summary line (that interviewers love):

â€œAll data types except objects are immutable and stored by value. Objects are mutable and stored by reference.â€

ðŸ’¡ Why it impresses: You show both classification and storage behavior awareness.

ðŸ’¬ Question 2: Whatâ€™s the difference between null and undefined?
âœ… Answer:
undefined means a variable has been declared but not assigned a value.

let a;
console.log(a); // undefined

null means a variable is explicitly set to have no value.

let b = null;
console.log(b); // null

âœ… Bonus tip line:

â€œundefined is the default state, while null is an intentional assignment.â€

ðŸ’¡ Why it impresses: This shows you understand the semantic difference, not just the definition.

ðŸ’¬ Question 3: What is the difference between primitive and non-primitive data types?
âœ… Answer:
Primitive types are immutable and stored by value.
Each variable holds its own copy.

let a = 10;
let b = a;
b = 20;
console.log(a); // 10

Non-primitive types (objects) are mutable and stored by reference.

let obj1 = { name: "Maha" };
let obj2 = obj1;
obj2.name = "Khan";
console.log(obj1.name); // Khan

ðŸ’¡ Why it impresses: You show that you understand how data is stored in memory.

ðŸ’¬ Question 4: How can you check the data type of a variable in JavaScript?
âœ… Answer:
You can use the typeof operator:

typeof "Hello" // "string"
typeof 10 // "number"
typeof true // "boolean"
typeof undefined // "undefined"
typeof null // "object" (this is a historical bug)
typeof Symbol() // "symbol"
typeof 123n // "bigint"

ðŸ’¡ Why interviewers love this:
If you mention the typeof null bug, it shows youâ€™ve gone beyond basic tutorial knowledge.

ðŸ’¬ Question 5: Why does typeof null return â€œobjectâ€?
âœ… Answer:
Itâ€™s a long-standing bug in JavaScript.
When JavaScript was first created, values were stored in a way where the type tag for objects was 0.
null was represented as a null pointer (0x00), which mistakenly got identified as an object.

Even though this was recognized as an error, it remains for backward compatibility.

ðŸ’¡ Why it impresses:
Knowing this shows a deep understanding of JavaScriptâ€™s internals.

ðŸ’¬ Question 6: What is type coercion in JavaScript?
âœ… Answer:
Type coercion is JavaScriptâ€™s automatic conversion of one data type to another when performing operations between different types.

Example:

console.log('5' + 2); // "52" â†’ number is converted to string (concatenation)
console.log('5' - 2); // 3 â†’ string is converted to number (subtraction)

âœ… Bonus line:

â€œType coercion can be implicit (automatic) or explicit (using Number(), String(), Boolean()).â€

ðŸ’¡ Why it impresses:
This question checks your understanding of dynamic typing and automatic conversions â€” key JavaScript behavior.

ðŸ’¬ Question 7: What is NaN in JavaScript?
âœ… Answer:
NaN stands for â€œNot-a-Numberâ€.
It represents an invalid number or a failed numeric conversion.

Example:

Number("abc"); // NaN


âœ… Bonus facts:

typeof NaN â†’ "number" (because NaN is technically a numeric value)
To check for NaN, use Number.isNaN(), not == or ===, because:

NaN === NaN // false

ðŸ’¡ Why it impresses:
You demonstrate both concept knowledge and common pitfalls awareness.

ðŸ’¬ Question 8: How does JavaScript handle dynamic typing?

âœ… Answer:
JavaScript is a dynamically typed language â€” meaning you donâ€™t have to declare a variableâ€™s type.
A variable can hold different types at different times:

let data = 42; 
data = "Hello"; 
data = true;

The interpreter determines the type at runtime, not compile time.

ðŸ’¡ Why it impresses:
This shows that you understand language behavior, not just syntax.

ðŸ§© TOP INTERVIEW QUESTIONS: Type Conversion & Coercion
ðŸ’¬ Question 1: What is type conversion in JavaScript?

âœ… Answer:
Type conversion is the process of changing a value from one data type to another.

It can be of two types:

Implicit Conversion (Type Coercion) â€“ done automatically by JavaScript.

Explicit Conversion â€“ done manually by the developer using built-in functions.

Example:

// Implicit
console.log('5' + 2); // "52" â†’ Number is converted to string

// Explicit
console.log(Number('5') + 2); // 7 â†’ String converted to number


âœ… Bonus line:

â€œIn short, coercion happens automatically, while conversion is done intentionally.â€

ðŸ’¡ Why this answer stands out:
You define, differentiate, and give simple code â€” clear and professional.

ðŸ’¬ Question 2: What is the difference between implicit and explicit type conversion?

âœ… Answer:

Type	Description	Example
Implicit (Type Coercion)	Automatically performed by JS when different types are used together	'5' + 2 â†’ "52"
Explicit (Type Conversion)	Manually done using functions	Number('5') + 2 â†’ 7

âœ… Bonus phrase for the interviewer:

â€œImplicit conversion is convenient but risky; explicit conversion is predictable and preferred in clean code.â€

ðŸ’¡ Why interviewers like it:
You show awareness of good coding practices, not just theory.

ðŸ’¬ Question 3: How does JavaScript handle coercion with the â€œ+â€ operator?

âœ… Answer:
The + operator behaves differently depending on the data types involved:

If either operand is a string, JavaScript converts both to strings and concatenates them.

Otherwise, it converts both to numbers and performs addition.

Example:

console.log('5' + 2); // "52" â†’ String concatenation
console.log(5 + true); // 6 â†’ true becomes 1
console.log('5' + true); // "5true"


ðŸ’¡ Why it impresses:
You demonstrate that you understand operator-based coercion rules, which are a common source of bugs.

ðŸ’¬ *Question 4: What happens when you use other operators (like -, , /) with strings and numbers?

âœ… Answer:
For operators other than +, JavaScript tries to convert both operands to numbers.

Examples:

'10' - 2  // 8
'10' * '2'  // 20
'10' / '2'  // 5
'10' - 'a'  // NaN


ðŸ’¡ Why interviewers ask this:
They want to see if you understand the difference in how operators trigger coercion.

ðŸ’¬ Question 5: Whatâ€™s the output of this, and why?
console.log(1 + '2' + 3);
console.log(1 + +'2' + 3);


âœ… Answer:

1 + '2' + 3 â†’ "123"
â†’ First, 1 + '2' becomes '12' (string concatenation), then '12' + 3 â†’ '123'.

1 + +'2' + 3 â†’ 6
â†’ +'2' converts '2' to number 2, so 1 + 2 + 3 â†’ 6.

ðŸ’¡ Why it impresses:
It shows deep awareness of how coercion happens step-by-step and that you know the unary plus trick (+ before a string to convert it to a number).

ðŸ’¬ Question 6: What values are considered â€œfalsyâ€ in JavaScript?

âœ… Answer:
There are 7 falsy values in JavaScript:

false, 0, -0, "", null, undefined, NaN


Everything else is truthy.

Example:

if ("hello") console.log("truthy");
if (0) console.log("won't run");


ðŸ’¡ Why interviewers love this:
Falsy/truthy checks are core to writing clean conditionals.

ðŸ’¬ Question 7: What is the difference between == and === in JavaScript?

âœ… Answer:

== (loose equality) â†’ compares values after performing type coercion.

=== (strict equality) â†’ compares both value and type, with no coercion.

Examples:

'5' == 5   // true
'5' === 5  // false


âœ… Bonus line:

â€œAlways prefer === for reliable comparisons and to avoid hidden coercion.â€

ðŸ’¡ Why it impresses:
You show that you not only understand coercion but also follow best practices.

ðŸ’¬ Question 8: Explain this tricky case â€” [] == ![]

âœ… Answer:
Letâ€™s break it down step by step:

[] == ![]  // true


![] â†’ false (because empty arrays are truthy, negating makes it false)

So we get [] == false

JavaScript tries to convert [] to a primitive â†’ '' (empty string)

Then converts '' to number 0, and false to number 0

So 0 == 0 â†’ true

ðŸ’¡ Why itâ€™s gold:
You show you can analyze coercion step-by-step â€” a skill that separates juniors from strong developers.

ðŸ’¬ Question 9: How can you convert values explicitly to Number, String, and Boolean?

âœ… Answer:

Conversion	Methods	Example
To Number	Number(), parseInt(), parseFloat(), +	Number("5"), +'5'
To String	String(), .toString()	String(123), (123).toString()
To Boolean	Boolean(), !!	Boolean(1), !!"hello"

ðŸ’¡ Why this matters:
Shows you can handle data normalization in real-world code.

ðŸ’¬ Question 10: Whatâ€™s the difference between parseInt() and Number()?

âœ… Answer:

parseInt() parses up to the first non-numeric character and returns an integer.

Number() converts the entire string, and if itâ€™s invalid, returns NaN.

Example:

parseInt("42px"); // 42
Number("42px");   // NaN


ðŸ’¡ Why interviewers ask this:
It checks your practical debugging knowledge when handling user input or data parsing.

ðŸ§© TRICKY TYPE CONVERSION & COERCION QUESTIONS

(With step-by-step reasoning + answers interviewers love)

ðŸ’¬ Question 1:
console.log('5' + 3);
console.log('5' - 3);


âœ… Answer:

'5' + 3 â†’ "53"   // String concatenation  
'5' - 3 â†’ 2      // String converted to number


ðŸ§  Explanation:
The + operator performs concatenation when one operand is a string.
Other arithmetic operators (-, *, /) always convert to numbers.

ðŸ’¡ Interviewer tip:
Theyâ€™re testing if you really know that + behaves differently than other operators.

ðŸ’¬ Question 2:
console.log(true + false);


âœ… Answer:

1


ðŸ§  Explanation:

true â†’ 1

false â†’ 0

1 + 0 = 1

ðŸ’¡ What interviewer sees:
You know Boolean-to-number coercion rules.

ðŸ’¬ Question 3:
console.log('10' - '4' - '3' + '2');


âœ… Answer:

"32"


ðŸ§  Explanation:

'10' - '4' â†’ 6

6 - '3' â†’ 3

3 + '2' â†’ '32' (because + with string â†’ concatenation)

ðŸ’¡ What impresses interviewer:
You handle operator precedence and mixed coercion cleanly.

ðŸ’¬ Question 4:
console.log(1 + '2' + 3);
console.log(1 + +'2' + 3);


âœ… Answer:

"123"
6


ðŸ§  Explanation:

First line: '2' turns the first + into string concatenation.

Second line: +'2' converts '2' to 2, so 1 + 2 + 3 = 6.

ðŸ’¡ Key trick: The unary plus (+) converts strings to numbers.

ðŸ’¬ Question 5:
console.log('5' * '2');
console.log('5' * []);
console.log('5' * [2]);


âœ… Answer:

10
0
10


ðŸ§  Explanation:

'5' * '2' â†’ both converted to numbers â†’ 10.

[] â†’ "" â†’ 0.

[2] â†’ '2' â†’ 2.

ðŸ’¡ This tests:
Array-to-string coercion + empty array handling.

ðŸ’¬ Question 6:
console.log([] + []);
console.log([] + {});
console.log({} + []);


âœ… Answer:

""
"[object Object]"
0


ðŸ§  Explanation:

[] + [] â†’ both become empty strings â†’ "".

[] + {} â†’ "" + "[object Object]" â†’ "[object Object]".

{} at start is treated as a block, so +[] â†’ 0.

ðŸ’¡ This is a classic â€œWTF JavaScriptâ€ question â€” showing you know parsing quirks.

ðŸ’¬ Question 7:
console.log(false == '0');
console.log(false === '0');


âœ… Answer:

true
false


ðŸ§  Explanation:

== â†’ performs coercion: '0' â†’ 0, false â†’ 0, so equal.

=== â†’ no coercion â†’ different types.

ðŸ’¡ Rule: Always use === to avoid hidden coercion bugs.

ðŸ’¬ Question 8:
console.log(!!"false" == !!"true");


âœ… Answer:

true


ðŸ§  Explanation:
Both "false" and "true" are non-empty strings, hence truthy.
!! converts to Boolean â†’ both true.

ðŸ’¡ Lesson: The content doesnâ€™t matter â€” only if itâ€™s empty or not.

ðŸ’¬ Question 9:
console.log([] == ![]);


âœ… Answer:

true


ðŸ§  Explanation:

![] â†’ false (since [] is truthy)

So [] == false

[] â†’ "" â†’ 0, and false â†’ 0 â†’ true

ðŸ’¡ Why itâ€™s tricky:
This is one of the most famous coercion puzzles ever used in interviews.

ðŸ’¬ Question 10:
console.log(null == undefined);
console.log(null === undefined);


âœ… Answer:

true
false


ðŸ§  Explanation:

== â†’ considers null and undefined equal (special case in JS).

=== â†’ compares type too â†’ they differ.

ðŸ’¡ Interviewer insight:
Tests if you know the only case where == is valid in real-world code.

ðŸ’¬ Question 11:
console.log(typeof NaN);
console.log(NaN == NaN);


âœ… Answer:

"number"
false


ðŸ§  Explanation:

NaN is of type number (weird but true).

NaN is never equal to itself â€” must check with Number.isNaN().

ðŸ’¡ Extra point:
Mention Object.is(NaN, NaN) returns true (newer method).

ðŸ’¬ Question 12:
console.log('' == 0);
console.log('' === 0);


âœ… Answer:

true
false


ðŸ§  Explanation:
'' â†’ 0 in loose equality, but types differ under strict equality.

ðŸ’¡ Quick rule:
== does numeric conversion if both sides can be treated as numbers.

ðŸ’¬ Question 13:
console.log('' == false);
console.log(0 == false);


âœ… Answer:

true
true


ðŸ§  Explanation:

'' â†’ 0

false â†’ 0

Both become 0, hence true.

ðŸ’¡ Interviewer note:
Shows understanding of coercionâ€™s numeric pathway.

ðŸ’¬ Question 14:
console.log('2' > '12');
console.log(2 > '12');


âœ… Answer:

true
false


ðŸ§  Explanation:

'2' > '12' â†’ string comparison, checks character by character ('2' > '1').

2 > '12' â†’ '12' converted to 12, so 2 > 12 â†’ false.

ðŸ’¡ Takeaway:
String comparison is lexicographical, not numeric.

ðŸ’¬ Question 15:
console.log([] == 0);
console.log(['0'] == 0);


âœ… Answer:

true
true


ðŸ§  Explanation:

[] â†’ "" â†’ 0.

['0'] â†’ '0' â†’ 0.

ðŸ’¡ This one shows:
How toString() and valueOf() methods work behind coercion.